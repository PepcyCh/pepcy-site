---
title: Rust（Yew）开发个人博客的尝试
date: 2022-02-10 15:56:06
tags: [Rust]
---

自己在高二，也就是 2017 年时，于停课搞 OI 期间想着像不少 OIer 那样搞博客写题解，于是用常见的 Hexo + Github pages + freenom 白嫖套装搞了一个，直至 2019 年 ICPC EC Final 退役后再也没更过什么和算法竞赛相关的文章，取而代之的是一些以 CG 为主的笔记，于是有了把二者分在两个子页面下的想法，而 Hexo 似乎不太能支持的样子，再到学校里的 BS 架构应用开发课程大程写了个 [Rust 前端 + 后端网页](https://github.com/PepcyCh/bs-app)后，有了这次拿 Rust 自己写一遍的想法，直到今年过年期间才开始行动，现在已经算是基本整好了。

至于为什么是 Rust，那段时间相当沉迷于 Rust，看到了 [Yew](https://yew.rs/) 这个 Rust 前端框架，又对 js 有一定的偏见，就成这样了。博客相关的代码在 [PepcyCh/pepcy-site](https://github.com/PepcyCh/pepcy-site)，网页在 [pepcy.top](pepcy.top)。

整体可能会有各种奇怪的实现，毕竟是写的第二个网页应用。

<!-- more -->

## 设计

因为一开始主要的目的是把算法竞赛相关的内容和其他笔记分在两个子页面下，即 `/algo/文章` 和 `/note/文章` 这样的形式，`/algo` 和 `/note` 是各自的文章列表首页，`/algo/tags` 和 `/note/tags` 显示各自的文章标签列表。很显然，只要实现其中一个，另一个只是 URL 上的区别，所以只要考虑一个这样的博客网站要怎么做。（实际中，除了原有的算法竞赛相关和笔记外，还增加了一个 ACGN 相关，准备想起来的时候放各种相关的碎碎念）

对于内容的处理，有两个思路，一是把博客机器标签的都存在后端数据库，后端去做一些数据库查询，二是预处理出各种想要的信息到一些文件，要什么就取哪个文件。因为不想写后端，所以选择了后者，把数据都处理成若干 json 文件。至于具体需要哪些信息，观察原来的博客后可以列出来如下（分类的话，因为已经按分类拆开了，所以就没支持）：

* 博客列表：每一页对应一个 json，包含这一页的博客的标题、URL、时间、标签、摘要等信息。
* 博客内容：每篇文章对应一个 json，包含文章标题、时间、标签、正文、目录等信息。
* 标签列表：在一个 json 中，包含每个标签的名称、URL、对应的文章数。
* 标签博客列表：每个标签对应一个 json，包含对应的博客的标题。

对于博文，一是要支持原来的那些文章，二是原来那样也方便，所以继续使用 Markdown，标题、时间、标签等信息在其 front matter 中。预处理生成 json 时也把 Markdown 处理为 HTML，目录显示也是提前根据生成的 HTML 再处理得到的 HTML 片段。

## 实现

### 预处理

Markdown 预处理使用了 [comrak](https://crates.io/crates/comrak)（支持代码高亮等特性）；公式在这之前用 [katex-rs](https://crates.io/crates/katex) 先处理成 Markdown 内嵌 HTML，用正则表达式找行内公式和公式块，然后调用 katex 替换内容，因为代码中的 `$` 不表示公式，需要判断，先是写正则时不在内部允许作为行内代码和代码块定界符的反点 ，此时识别到的部分不是真的公式就是全部在代码中，好在行内代码的定界符是 1 个点，代码块是 3 个点，只要判断在这之前的点的数目是奇数还是偶数就能知道是哪一种情况；目录的部分，comrak 支持在各级标题生成 id，就可以用 `/#id` 来跳转了，也是用正则表达式识别出各个标题及 comrak 给出的 id，然后根据标题级别生成正确的多层有序列表 HTML 片段。

Front matter、标签等的处理就比较简单了。

因为重复生成文章对应的 HTML 还是比较耗时的，所以额外用一个 json 记录每个文章最新一次生成时的编辑时间。

### 前端

前端框架使用了 [Yew](https://yew.rs/) 配合 [trunk](https://github.com/thedodd/trunk)（提供了简单的后端功能，而且支持 Rust 前端代码的热重载），新的 Yew 0.19 更新后变化有点大，感觉整体更接近 React 了。然后也因为这个更新，本来数目就不算多的 Yew 组件库很多都不能用，好在有 [Bulma.css](https://bulma.io/) 这种 CSS 框架，看了一眼 Yew 组件库之一的 [ybc](https://github.com/thedodd/ybc) 就是把它封装了一下，所以就直接用 Bulma 了。除了个别内容，主要是目录的有序列表，没有做什么额外的 CSS 编写。

因为支持了多层路由（route），所以第一层就是

* / - 主页
* algo - 算法竞赛博客
* note - 笔记博客
* acgn - ACGN 博客
* about - 关于
* 404 - 404 页

几个博客的子路由就是

* / - 博客主页（第一页博客列表）
* 数字 - 第 X 页博客列表
* tags - 标签列表
* 文章标题 - 博文
* tags/标签名 - 含某标签的博客列表

每一个写一个组件。

对于博客相关的这几个，因为要请求 json 文件，所以用了完整的组件结构，其余都直接用函数组件就好了。请求用了 [reqwasm](https://github.com/hamza1311/reqwasm)，[reqwest](https://crates.io/crates/reqwest) 用的 URL 库会不认相对路径。

说到 URL，还一个问题是百分号编码，在不同地方用的时候得注意编码和反编码，编码有现成的 [percent_encoding](https://docs.rs/percent-encoding/2.1.0/percent_encoding/)，反编码就手写了。

对于预处理得到的 HTML，直接放进内容里是会被认作纯字符串而不是一段有效的 HTML，不过 Yew 的 issue 里有人给过解决方案，我这里稍微改成了 0.19 后的函数组件。

整个前端再好像就没有什么坑了，主要就是在对着 Bulma 的文档放各种组件，没有什么过于复杂的地方。

## 部署

部署在服务器上用了 Nginx，主要就两点，一是 wasm 的 MIME 类型要在 `mime.types` 或 `nginx.conf` 里加一下，二是 server 里写个就行了（参考了 https://sdickinson.com/nginx-config-for-single-page-applications/），就是最后导到根下让路由的那套逻辑能跑起来，否则直接进那些 URL 连 js & wasm 都不会加载进来。

```nginx
location / {
    try_files $uri $uri/ $uri.html /index.html;
}
```

域名及其解析用了阿里云。

## 未来

校内课程大程时，有些内容被迫还是写了 js，没能做到纯 Rust，这次做到了还是挺开心的。

有了自己的代码后，想搞什么就比较舒服了，比如在 front matter 里搞点自定义的内容，或者前端给什么内容打个洞，甚至 wgpu 的 web 实战；服务器也是，图片也可以考虑不用图床而是直接传上服务器了。

公式的预处理，不知道为什么处理各种矩阵时会炸掉，还没仔细看过。

原来用 GitHub pages 的还有 *CPC 用板子的网络版，可以考虑也放进来，pdf 也是。虽然早已离开算法竞赛了，但去年有看到学弟用上了我的板子还挺开心的，所以就不扔掉了。
